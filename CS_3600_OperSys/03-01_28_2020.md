# <div style="text-align: right"> January 28, 2020</div>

### Agenda:
- Operating System Services
- User and Operating System-Interface
- System Calls
- System Services
- Linkers and Loaders
### Homework:
-
---
## I. Operating System Services
- Operating Systems provide an environment for execution of programs and services to programs and users
- OS services provides functions that are helpful to the user:
    - `User interface`:
        - Almost all operating systems have a user interface (`UI`).
        - Varies between Command-line (`CLI`), Graphics User Interface (`GUI`), touch-screen.
    - `Program execution`:
        - The system must be able to load a program into memory and to run that program, end execution, either normally or abnormally (indicating error)
    - `I/O Operations`:
        - A running program may require I/O, which may involve a file or an I/O device.
    - `File-system manipulation`:
        - The file system is of particular interest.
        - Programs need to read and write files and directories, create and delete them, search them, list file information, permission management.
    - `Communications`:
        - Processes may exchange information, on the same computer or between computers over a network.
            - Communications may be via shared memory or through message passing (packets moved by the OS)
    - `Error Detection`:
        - OS needs to be constantly aware of possible erros
            - May occur in the CPU and memory hardware, in I/O devices, in user program.
            - For each type of error, OS should take the appropriate action to ensure correct and consistent computing 
            - Debugging facilities can greatly enhance the user's and programmer's abilities to efficiently use the system.
    - `Resource allocation`: 
        - When multiple users or multiple jobs running concurrently, resources must be allocated to each of them
            - Many types of resurces
                - CPU cycles
                - main memory
                - file storage
                - I/O devices
    - `Logging`:
        - To keep track of which users use how much and what kinds of computer resources.
    - `Protection and security`:
        - The owners of information stored in a multiuser or networked computer system may want to control use of that information stored in a multisuer or networked computer system may want to control use of that information, concurrent processes should not interfere with each other.
            - `Protection`: 
                - Involves ensuring that all access to system resources is controlled.
            - `Security`:
                - The system from outsiders requires user authentication, extends to defending external I/O devices from invalid access attempts
---
### Question 1
The hardware/user gap is bridged by the OS or by other system software. Which of the following tasks would require OS support?
- `Input a character from the keyboard`
- Invoke a high-level matrix manipulation operation.
- `Allocate n bytes of memory for a new data structure`
- `Load a program into memory`
- `Call a library function`
- Call a function defined within the current program
- `Exit current program`
- `Sleep the program for n seconds`
### Question 2
- Kernel functions may be invoked by `Any Program`
- Priviledged instructions may be executed by `Kernel Only`
- An application that needs to access an I/O device could not be written without `Kernel functions`
- The kernel can execute `both priviledged and non privileged` instructions.
---
## II. User Operating System Interface
- CLI
    - CLI or `command line interpreter` allows direct command entry
        - Sometimes implemented in kernel, sometimes by systems program.
        - Sometimes multiple flavors implemented - `shells`
        - Primarily fetches a command from user and executes it
        - Sometimes commands built-in, somtimes just names of programs
- GUI
    - User-friendly desktop metaphor interface
        - Usually `mouse`, `keyboard`, and `monitor`
        - `Icons` represent files, programs, action, etc.
        - Various mouse buttons over objects in the interface `cause various actions` (provide information, options, execute function, open directory (folder))
    - Many systems now include both CLI and GUI interfaces
        - Microsoft Windows is GUI with CLI "command" shell
        - Apple Mac OS X is "Aqua" GUI interface with UNIX kernel underneath and shells available
        - Unix and linux have CLI with optional GUI interfaces (CDE, KDE, GNOME)
---
## III. System Calls
- Programming interface to the services provided by the OS
- Typically written in a high-level language (C or C++)
- Mostly accessed by programs via a high-level `Application Programming Interface` (API) rather than direct system call use
- Three most common API's are:
    - `Win32 API` for Windows
    - `POSIX API` for POSIX-based systems (including virtually all versions of UNIX, Linux, and Mac OS X).
    - `Java API` for the Java Virtual Machine (JVM)
---
## IV. System Call Implementation
- Typically, a number associated with each system call
    - `System-call interface` maintains a table indexed according to these numbers.
- The system call interface invokes the intended system call in OS Kernel and returns status of the system call and any return values.
- The caller need know nothing about how the system call is implemented
    - Just needs to obey API and understand what OS will do as a result call
    - Most details of OS interface hidden from programmer by API
---
## V. System Call Parameter Passing
- Often, more information is required than simply identity of desired system call
    - Exact type and amount of information vary according to OS and call
- Three general methods used to pass parameters to the OS
    - Simplest: pass the parameters in `registers`
        - In some cases, may be more parameters than registers
    - Parameters stored in a block, or table, in memory, and address of block passed as a parameter in a register.
        - This approach taken by Linux and Solaris
    - Parameters placed, or `pushed`, onto the `stack` by the program and `popped` off the stack by the operating system.
    - Block and stack methods do not limit the number or length of parameters being passed.
---
## VI. Types of System Calls
- Process Control
    - Create process, terminate process
    - end, abort
    - load, execute
    - get process attributes, set process attributes
    - wait for time
    - wait event, signal event
    - allocate and free memory
    - Dump memory if error
    - `Debugger` for determining `bugs`, `single step` exection
    - `locks` for managing access to shared data between processes
- File management
    - create file, delete file
    - open, close file
    - read, write, reposition
    - get and set file attributes
- Device management
    - request device, release device
    - read, write, reposition
    - get device attributes, set device attributes
    - logically attach or detach devices
- Information maintenance
    - get time or date, set time or date
    - get system data, set system data
    - get and set process, file, or device attributes
- Communications
    - create, delete communication connection
    - send, receive messages if `message passing model` to `host name` or `process name`
        - From `client` to `server`
    - `Shared-memory model` create and gain access to memory regions
    - Transfer status information
    - attach and detach remote devices
- Protection
    - Control access to resources
    - Get and set permissions
    - Allow and deny user access
---
### Question 3
- A System call is a `library function`
- A supervisor call is a `privileged instruction`
- A supervisor call can be executed `any program`
- Changing the mode bit of the CPU `from user mode to kernel mode` can only be done by a privileged instruction.
---
## XII. System Services
- System programs provide a convenient environment for program development and execution. They can be divided into:
    - File Manipulation
    - Status Information sometimes stored in a file
    - Programming language support
    - Program loading and execution
    - Communications
    - Background services
    - Application programs
- Most users' view of the operation system is defined by system programs, not the actual system calls
- Provide a convenient environment for program development and execution
    - Some of them are simply user interfaces to system calls; others are considerably more complex
- `File management`:
    - Create, delete, copy, rename, print, dump, list, and generally manipulate files and directories.
- `Status information`:
    - Some ask the system for info
        - date, time amount of available memory, disk space, number of users
    - others provide detailed performance, logging, and debugging information.
    - Typically, these programs format and print the output to the terminal or other output devices.
    - Some system implement a `registry` - used to store and retrieve configuration information. 
- `File modification`:
    - Text editors to create and modify files
    - Special commands to search contents of files or perform transformations of the text.
- `Programming-language support`:
    - compilers, assemblers, debuggers, and interpreters sometimes provided
- `Program loading and execution`:
    - Absolute loaders, relocatable loaders, linkage editors, and overlay-loaders, debugging systems for higher-level and machine language.
- `Communications`:
    - Provide the mechanism for creating virtual connections among processes, users, and computer systems.
        - Allow users to send messages to one another's screens, browse web pages, send electronic-mail messages, log in remotely, transfer files from one machine to another.
- `Background Services`:
    - Launch at boot time
        - Some for system startup, then terminate
        - some from system book to shutdown
    - Provide facilities like disk checking, process scheduling, error logging, printing
    - Run in user context not kernel context
    - Known as `services`, `subsystems`, `daemons`
- `Application Programs`
    - Don't pertain to system
    - Run by users
    - Not typically considered part of OS
    - Launched by command line, mouse click, finger poke
---
## VIII. Linkers and Loaders
- Source code compiled into object files designed to be loaded into any physical memory location - `relocatable object file`
- `Linker` combines these into single binary `executable` file
    - also brings in libraries
- Program resides on secondary storage as binary executable
- Must be brought into memory by `loader` to be executed
    - `Relocation` assigns final addresses to program parts and adjusts code and data in program to match those addresses.
- Modern general-purpose systems don't link libraries into executables
    - Rather, `dynamically linked libraries` (in Windows, `DLL`s) are loaded as needed, shared by all that use the same version of that same library (loaded once)
- Object, executable files have standard formats, so operating system knows how to load and start them.
---
## IX. Why Applications are Operating System Specific
- Apps compiled on one system usually not executable on other operating systems.
- Each operating system provides its own unique system calls
    - Own file formats, etc
- Apps can be multi-operating system
    - Written in interpreted language like Python, Ruby, and interpreter available on multiple operating systems
    - App written in language that includes a VM containing the running app (like Java)
    - Use standard language (like C), compile separately on each operating sysem to rn on each.
- `Application Binary interface` (`ABI`) defines how different components of binary code can interface for a given operating system on a given architecture, CPU, etc.
---
## X. Operating System Design and Implementation
- `User` goals and `System` goals
    - User goals:
        - Operating system should be convenient to use, easy to learn, reliable, safe, and fast.
    - System Goals:
        - Operating system should be easy to design, implement, and maintain, as well as flexible, reliable, error-free, and efficient.
        - Important Principle ot Separate
            - `Policy`: What will be done?
            - `Mechanism`: How to do it?
        - The separation of policy from mechanism is a very important principle.
            - It allows maximum flexibility if policy decisions are to be changed later (example - timer)
        - Specifying and designing an OS is highly creative task of `software engineering`
---
## XI. Implementation
- Much variation:
    - Early OSes in assembly language
    - Then system programming languages like Algol, PL/1
    - Now C, C++
- Actually usually a mix of languages
    - Lowest levels in assembly
    - Main body in C
    - Systems programs in C, C++, scripting languages like PERL, Python, shell scripts
- More high-level language easier to `port` to other hardware
    - but slower
- `Emulation` can allow an OS to run on non-native hardware
---
## XII. Operating System Structure
- General-purpose OS is very large program
- Various ways to structure ones
    - Simple structure - MS-DOS
    - More complex -- UNIX
    - Layered - an abstraction
    - Microkernel - Mach
---
## XIII. Monolithic Structure - Original UNIX
- UNIX
    - Limited by hardware functionality
    - The original UNIX operating system had limited structuring
    - The UNIX OS consists of two separable parts
- Systems programs
- The Kernel:
    - Consists of everything below the system - call interface and above the physical hardware
    - Provides the file system, CPU scheduling, memory management, and other operating-system functions; a large number of functions for one level.
---
## 14. Layered Approach
- The operating system is divided into a number of layers (levels), each built on top of lower layers.
- The bottom layer (layer 0), is the hardware; the highest (layer N) is the user interface.
- With modularity, layers are selected such that each uses functions (operations) and services of only lower-level layers.
---
## 15. Microkernels
- Moves as much from the kernel into user space
- `Mach` example of `microkernel`
    - Mac OS X kernel (`Darwin`) partly based on Mach
- Communication takes place between user modules using `message passing`
- Benefits:
    - Easier to extend a microkernel
    - Easier to port the operating system to new architectures
    - more reliable (less code is running in kernel mode)
    - more secure
- Detriments:
    - Performance overhead of user space to kernel space communication 
---
## 16. Modules
- Many Modern operating systems implement `loadable kernel modules` (`LKM`s)
    - Uses object-oriented approach
    - Each core component is separate
    - Each talks to the others over known interfaces
    - Each is loadable as needed within the kernel
- Overall, Similar to layers but with more flexible
    - Linux, Solaris, etc.
---
## 17. Hybrid Systems
- Most modern operating systems are actually not one pure model
    - Hybrid combines multiple approaches to address performance, security, usability needs.
    - Linux and solaris kernels in kernel address space, so monolithic, plus modular for dynamic loading of fuctionality.
    - Windows mostly monolithic, plus microkernel for different subsystem `personalities`
- Apple Mac OS X Hybrid, layered, `Aqua` UI plus `Cocoa` programming environment
    - Below is kernel consisting of Mach microkernel and BSD Unix parts, plus I/O kit and dynamically loadable modules (called `kernel extensions`)
---
## 18. Android
- Developed by Open Handset Alliance (mostly Google)
    - Open Source
- Similar stack to IOS
- Based on Linux kernel but modified
    - Provides process, memory, device-driver management
    - adds power management
- Runtime environment includes core set of libraries and Dalvik virtual machine
    - apps developed in Java plus Android API
        - Java Class files compiled to Java bytecode then translated to executable then runs in Dalvik VM
- Libraries include frameworks for web browser (webkit), database (SQLite), multimedia, smaller libc
---
## 19. Building and Booting an Operating System
- Operating systems generally designed to run on a class of systems with variety of peripherals.
- Commonly, operating system already installed on purchased computer
    - But can build and install some other operating systems
    - If generating an operating system from scratch
        - Write the operating system source code
        - Configure the operating system for the system on which it will run
        - Compile the operating system
        - Install the operating system
        - Boot the computer and its new operating system
---
## 20. Building and Booting Linux
- Download Linux source code (http://wwww.kernel.org)
- Configure kernel via "`make menuconfig`"
- Compile the kernel using "`make`"
    - Produces `vmlinuz`, the kernel image
    - Compile kernel modules via "`make modules`"
    - Install kernel modules into `vmlinux` via "`make modules_install`"
    - Install new kernel on the system via "`make install`"
- System Boot
    - When power initialized on system, execution starts at a fixed memory location.
    - Operating system must be made available to hardware so hardware can start it.
        - Small piece of code - `bootstrap loader`, `BIOS`, stored in `ROM` or `EEPROM` locates the kernel, loads it into memory, and starts it.
        - Sometimes two-step process where `boot block` at fixed location loaded by ROM code, which loads bootstrap loader from disk.
        - Modern systems replace BIOS with Unified Extensible Firmware Interface (UEFI)
    - Common boostrap loader, `GRUB`, allows selection of kernel from multiple disks, versions, kernel options.
    - Kernel loads and system is then `running`
    - Boot loaders frequently allow various boot states, such as single user mode.
- Operating-System debugging
    - `Debugging` is finding and fixing errors, or `bugs`
    - Also `performance tuning`
    - OS generated `log files` containing error information
    - Failure of an application can generate `core dump` file capturing memory of the process.
    - Operating system failure can generate `crash dump` file containing kernel memory
    - Beyond crashes, performance tuning can optimize system performance.
        - Sometimes using `trace listings` of activities, recording for analysis
        - `Profiling` is periodic sampling of instruction pointer to look for statistical trends
    - Kernighan's Law:
        - "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."
    - Performance Tuning 
        - Improve performance by removing bottlenecks
        - OS must provide means of computing and displaying measures of system behavior.
        - For example, "top" program or Windows Task Manager
    - Tracing
        - Collects data for specific event, such as steps involved in a system call invocation.
        - Tools include:
            - Strace:
                - Trace system calls invoked by a process
            - gdb:
                - Source-level debugger
            - perf:
                - Collection of Linux performance tools
            - tcpdump
                - Collects Network Packets
    - BCC
        - Debugging interactions between user-level and kernel code neraly impossible wihtout toolset that understands both and an instrument their actions
        - BCC (BPF Compiler Collection) is a rich toolkit providing tracing for Linux
            - See also the original Dtrace
        - For example, disksnoop.py races disk I/O activity
---
