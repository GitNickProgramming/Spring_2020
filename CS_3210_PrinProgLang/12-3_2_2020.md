# <div style="text-align: right">Principles of Programming Language - March 2, 2020</div>
### Agenda:
- Quiz
- Homework Questions
- Functional Programming

### Homework:
---
## I. Introduction
- Functional Programming is a method of program construction that emphasizes functions and their applications rather than commands and their execution.
- Programming in a functional language consists of building definitions and using the computer to evaluate expressions.
- An expression is used to describe (or denote) a value.
- Example
```python
x = 5 (definition)
y = 3 (definition)
x + y is an expression that evalues to 8
```
- Haskell is functional programming language developed in the 90s
- Functional programming in Haskell means tha program is defined as the evaluation of "pure" functions
- Haskell 'pure' functions have the following properties:
    - Return the value is the same for the same arguments.
    - Its evaluation has no *side effects*
```python

# Same function definition and calls but different results
def fun(x):
    if x > y:
        return x
    return y
    

y = 3
print(fun(5))


def fun(x):
    if x > y:
        return x
    return y
    
    
y = 7
print(fun(5))

# Function with side effect!
def greet(name):
    print("Hi " + name + "!")
    

greet("Mary")
```
- Example
    - add `x y = x + y` is a function that when given two integers `x` and `y` returns their sum (x + y).
    - add 5 3 is an expression that is *always* evaluated to 8
- Haskell is named after Haskell B. Curry who was one of the pioneers of the lambda calculus, a mathematical theory of functions.
- Lambda Calculus:
    - Variable x is a term
    - if `t` is a term and `x` is a variable, then `(lambda x . t)` is also a term
    - If `t` and `s` are terms, then `(ts)` is also a term.
    - `lambda x.x^2` is a term representing `f(x) = x^2`
    - `(lambda x.x^2)3` is a term representing `f(3) = 3^2 = 9`
---
## II. Getting Haskell
- The glasgow Haskell Compiler:
    - Probably the most fully featured Haskell compiler today is the Glasgow Haskell Compiler (GHC), is an open-source project with a liberal BSD-style licence
    - Current Stable version is 8.8.3(Feb. 2020)
- The Haskell Platform distribution comes with:
    - The Glasgow Haskell Compilier
    - The Cabal build system, which can install new packages, and by default fetches from Hackage, the central Haskell package repositroy.
    - The Stack tool for developing projects
    - Support for profiling and code coverage analysis
    - 25 core and & widely-used packages.
- Command-lines Tools available in GHC:
    - ghc : GHC's compiler
    - runghc : GHC's Interpreter
    - ghci : GHC's interactive environment
---
## III. Haskell Types 
- Haskell type system is static (variable types are efined at compilation time, remaining the same while the program runs)
- There is no explicit declaration and the types are automatically inferred.
- Char
    - represents a character; it's denoted by single quotes; a list of characters is a string.
    - `c = 'a'`
    - `:type c`
    - `c :: Char`
- Bool
    - True or False
    - `b = true`
    - `:type b`
    - `b :: Bool`
- Num
    - Provides several basic operations common to all numeric types, including addition, subtraction, negation, multiplication, and absolute value.
    - Num can be `Integral` or `Fractional`
- Num : Integral
    - Provides integer division and remainder
    - Implemented by `Int` and `Integer`
    - `Int` is used bounded integers, usually implemented by hardware; on 64-bit machine int values range from **`[-2^63, 2^63-1]`**
    - `Integer` is for unbounded integers (however, less efficient than Int)
- Num : Fractional
    - Provides real division
    - implemented by `Float` (single-precision) and `Double` (double precision) floating-point values.
- Conversion rule for numerical literal values:
    - Literals with no decimals are defined as `Num`
    - The moment Haskell needs to choose a specific type, it uses the defaulting rules, normally `Integer`
    - Literal with decimals are initially set to `Fractional`, which is normally defaulted to `Double`.
    - You can use `default(Int, Float)` to change the default rules for type inference.
- Lists:
    - all of the elements have to be of the same type
    - lists are mutable
- Tuples:
    - Elements do not have to be of the same type
    - Tuples are immutable
- () Type
    - It only has one value, also written as () and pronounced "unit"
    - You can think of this as similar to the `void` keyword in C family languages
    - You can return() from an I/O action if you don't want to return anything.
    - Functions in Haskell also have types
    - For example
        - function `lines` takes a string and returns a list of strings, based on the new lines found.
---
## IV. Haskell Variables
- In Haskell, a variable provides a way to give a name to an expression
- Once a variable is bound to a particular expresion, its values cannot be changed.
- `=` is the value-naming operator
- it is used to bind a name to a definition
- You should read = as 'is'
- List Functions:
    - head (1st element)
    - last (last element)
    - tail (list without the head)
    - init (list without the last element)
    - length (number of elements)
- Functions can take any kind of value as argument and return an kind of value as reult, including other functions
- A function that takes a function as argument, or delivers one as result, is called a higher-order function.
- Currying is the process of transforming a function that takes a tuple as its argument into a function that takes just a single argument and returns another function which accepts further arguments corresponding to the rest of that tuple.
- Haskell allows functions to be defined using pattern matching.
- Pattern matching consists of specifying patterns to which some data should conform and then checking to see if it does and deconstructing the data according to those patterns 